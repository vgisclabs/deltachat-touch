// copied from deltachat core / jsonrpc / typescript / dist/generated/client.js 
// and rename the extention to .mjs

// AUTO-GENERATED by yerpc-derive
export class RawClient {
    constructor(_transport) {
        this._transport = _transport;
    }
    /**
     * Test function.
     */
    sleep(delay) {
        return (this._transport.request('sleep', [delay]));
    }
    /**
     * Checks if an email address is valid.
     */
    checkEmailValidity(email) {
        return (this._transport.request('check_email_validity', [email]));
    }
    /**
     * Returns general system info.
     */
    getSystemInfo() {
        return (this._transport.request('get_system_info', []));
    }
    /**
     * Get the next event.
     */
    getNextEvent() {
        return (this._transport.request('get_next_event', []));
    }
    addAccount() {
        return (this._transport.request('add_account', []));
    }
    removeAccount(accountId) {
        return (this._transport.request('remove_account', [accountId]));
    }
    getAllAccountIds() {
        return (this._transport.request('get_all_account_ids', []));
    }
    /**
     * Select account id for internally selected state.
     * TODO: Likely this is deprecated as all methods take an account id now.
     */
    selectAccount(id) {
        return (this._transport.request('select_account', [id]));
    }
    /**
     * Get the selected account id of the internal state..
     * TODO: Likely this is deprecated as all methods take an account id now.
     */
    getSelectedAccountId() {
        return (this._transport.request('get_selected_account_id', []));
    }
    /**
     * Get a list of all configured accounts.
     */
    getAllAccounts() {
        return (this._transport.request('get_all_accounts', []));
    }
    /**
     * Starts background tasks for all accounts.
     */
    startIoForAllAccounts() {
        return (this._transport.request('start_io_for_all_accounts', []));
    }
    /**
     * Stops background tasks for all accounts.
     */
    stopIoForAllAccounts() {
        return (this._transport.request('stop_io_for_all_accounts', []));
    }
    /**
     * Starts background tasks for a single account.
     */
    startIo(accountId) {
        return (this._transport.request('start_io', [accountId]));
    }
    /**
     * Stops background tasks for a single account.
     */
    stopIo(accountId) {
        return (this._transport.request('stop_io', [accountId]));
    }
    /**
     * Get top-level info for an account.
     */
    getAccountInfo(accountId) {
        return (this._transport.request('get_account_info', [accountId]));
    }
    /**
     * Get the combined filesize of an account in bytes
     */
    getAccountFileSize(accountId) {
        return (this._transport.request('get_account_file_size', [accountId]));
    }
    /**
     * Returns provider for the given domain.
     *
     * This function looks up domain in offline database.
     *
     * For compatibility, email address can be passed to this function
     * instead of the domain.
     */
    getProviderInfo(accountId, email) {
        return (this._transport.request('get_provider_info', [accountId, email]));
    }
    /**
     * Checks if the context is already configured.
     */
    isConfigured(accountId) {
        return (this._transport.request('is_configured', [accountId]));
    }
    /**
     * Get system info for an account.
     */
    getInfo(accountId) {
        return (this._transport.request('get_info', [accountId]));
    }
    /**
     * Sets the given configuration key.
     */
    setConfig(accountId, key, value) {
        return (this._transport.request('set_config', [accountId, key, value]));
    }
    /**
     * Updates a batch of configuration values.
     */
    batchSetConfig(accountId, config) {
        return (this._transport.request('batch_set_config', [accountId, config]));
    }
    /**
     * Set configuration values from a QR code. (technically from the URI that is stored in the qrcode)
     * Before this function is called, `checkQr()` should confirm the type of the
     * QR code is `account` or `webrtcInstance`.
     *
     * Internally, the function will call dc_set_config() with the appropriate keys,
     */
    setConfigFromQr(accountId, qrContent) {
        return (this._transport.request('set_config_from_qr', [accountId, qrContent]));
    }
    checkQr(accountId, qrContent) {
        return (this._transport.request('check_qr', [accountId, qrContent]));
    }
    /**
     * Returns configuration value for the given key.
     */
    getConfig(accountId, key) {
        return (this._transport.request('get_config', [accountId, key]));
    }
    batchGetConfig(accountId, keys) {
        return (this._transport.request('batch_get_config', [accountId, keys]));
    }
    setStockStrings(strings) {
        return (this._transport.request('set_stock_strings', [strings]));
    }
    /**
     * Configures this account with the currently set parameters.
     * Setup the credential config before calling this.
     */
    configure(accountId) {
        return (this._transport.request('configure', [accountId]));
    }
    /**
     * Signal an ongoing process to stop.
     */
    stopOngoingProcess(accountId) {
        return (this._transport.request('stop_ongoing_process', [accountId]));
    }
    exportSelfKeys(accountId, path, passphrase) {
        return (this._transport.request('export_self_keys', [accountId, path, passphrase]));
    }
    importSelfKeys(accountId, path, passphrase) {
        return (this._transport.request('import_self_keys', [accountId, path, passphrase]));
    }
    /**
     * Returns the message IDs of all _fresh_ messages of any chat.
     * Typically used for implementing notification summaries
     * or badge counters e.g. on the app icon.
     * The list is already sorted and starts with the most recent fresh message.
     *
     * Messages belonging to muted chats or to the contact requests are not returned;
     * these messages should not be notified
     * and also badge counters should not include these messages.
     *
     * To get the number of fresh messages for a single chat, muted or not,
     * use `get_fresh_msg_cnt()`.
     */
    getFreshMsgs(accountId) {
        return (this._transport.request('get_fresh_msgs', [accountId]));
    }
    /**
     * Get the number of _fresh_ messages in a chat.
     * Typically used to implement a badge with a number in the chatlist.
     *
     * If the specified chat is muted,
     * the UI should show the badge counter "less obtrusive",
     * e.g. using "gray" instead of "red" color.
     */
    getFreshMsgCnt(accountId, chatId) {
        return (this._transport.request('get_fresh_msg_cnt', [accountId, chatId]));
    }
    /**
     * Gets messages to be processed by the bot and returns their IDs.
     *
     * Only messages with database ID higher than `last_msg_id` config value
     * are returned. After processing the messages, the bot should
     * update `last_msg_id` by calling [`markseen_msgs`]
     * or manually updating the value to avoid getting already
     * processed messages.
     *
     * [`markseen_msgs`]: Self::markseen_msgs
     */
    getNextMsgs(accountId) {
        return (this._transport.request('get_next_msgs', [accountId]));
    }
    /**
     * Waits for messages to be processed by the bot and returns their IDs.
     *
     * This function is similar to [`get_next_msgs`],
     * but waits for internal new message notification before returning.
     * New message notification is sent when new message is added to the database,
     * on initialization, when I/O is started and when I/O is stopped.
     * This allows bots to use `wait_next_msgs` in a loop to process
     * old messages after initialization and during the bot runtime.
     * To shutdown the bot, stopping I/O can be used to interrupt
     * pending or next `wait_next_msgs` call.
     *
     * [`get_next_msgs`]: Self::get_next_msgs
     */
    waitNextMsgs(accountId) {
        return (this._transport.request('wait_next_msgs', [accountId]));
    }
    /**
     * Estimate the number of messages that will be deleted
     * by the set_config()-options `delete_device_after` or `delete_server_after`.
     * This is typically used to show the estimated impact to the user
     * before actually enabling deletion of old messages.
     */
    estimateAutoDeletionCount(accountId, fromServer, seconds) {
        return (this._transport.request('estimate_auto_deletion_count', [accountId, fromServer, seconds]));
    }
    initiateAutocryptKeyTransfer(accountId) {
        return (this._transport.request('initiate_autocrypt_key_transfer', [accountId]));
    }
    continueAutocryptKeyTransfer(accountId, messageId, setupCode) {
        return (this._transport.request('continue_autocrypt_key_transfer', [accountId, messageId, setupCode]));
    }
    getChatlistEntries(accountId, listFlags, queryString, queryContactId) {
        return (this._transport.request('get_chatlist_entries', [accountId, listFlags, queryString, queryContactId]));
    }
    /**
     * Returns chats similar to the given one.
     *
     * Experimental API, subject to change without notice.
     */
    getSimilarChatIds(accountId, chatId) {
        return (this._transport.request('get_similar_chat_ids', [accountId, chatId]));
    }
    getChatlistItemsByEntries(accountId, entries) {
        return (this._transport.request('get_chatlist_items_by_entries', [accountId, entries]));
    }
    getFullChatById(accountId, chatId) {
        return (this._transport.request('get_full_chat_by_id', [accountId, chatId]));
    }
    /**
     * get basic info about a chat,
     * use chatlist_get_full_chat_by_id() instead if you need more information
     */
    getBasicChatInfo(accountId, chatId) {
        return (this._transport.request('get_basic_chat_info', [accountId, chatId]));
    }
    acceptChat(accountId, chatId) {
        return (this._transport.request('accept_chat', [accountId, chatId]));
    }
    blockChat(accountId, chatId) {
        return (this._transport.request('block_chat', [accountId, chatId]));
    }
    /**
     * Delete a chat.
     *
     * Messages are deleted from the device and the chat database entry is deleted.
     * After that, the event #DC_EVENT_MSGS_CHANGED is posted.
     *
     * Things that are _not done_ implicitly:
     *
     * - Messages are **not deleted from the server**.
     * - The chat or the contact is **not blocked**, so new messages from the user/the group may appear as a contact request
     *   and the user may create the chat again.
     * - **Groups are not left** - this would
     *   be unexpected as (1) deleting a normal chat also does not prevent new mails
     *   from arriving, (2) leaving a group requires sending a message to
     *   all group members - especially for groups not used for a longer time, this is
     *   really unexpected when deletion results in contacting all members again,
     *   (3) only leaving groups is also a valid usecase.
     *
     * To leave a chat explicitly, use leave_group()
     */
    deleteChat(accountId, chatId) {
        return (this._transport.request('delete_chat', [accountId, chatId]));
    }
    /**
     * Get encryption info for a chat.
     * Get a multi-line encryption info, containing encryption preferences of all members.
     * Can be used to find out why messages sent to group are not encrypted.
     *
     * returns Multi-line text
     */
    getChatEncryptionInfo(accountId, chatId) {
        return (this._transport.request('get_chat_encryption_info', [accountId, chatId]));
    }
    /**
     * Get QR code (text and SVG) that will offer an Setup-Contact or Verified-Group invitation.
     * The QR code is compatible to the OPENPGP4FPR format
     * so that a basic fingerprint comparison also works e.g. with OpenKeychain.
     *
     * The scanning device will pass the scanned content to `checkQr()` then;
     * if `checkQr()` returns `askVerifyContact` or `askVerifyGroup`
     * an out-of-band-verification can be joined using `secure_join()`
     *
     * chat_id: If set to a group-chat-id,
     *     the Verified-Group-Invite protocol is offered in the QR code;
     *     works for protected groups as well as for normal groups.
     *     If not set, the Setup-Contact protocol is offered in the QR code.
     *     See https://countermitm.readthedocs.io/en/latest/new.html
     *     for details about both protocols.
     *
     * return format: `[code, svg]`
     */
    getChatSecurejoinQrCodeSvg(accountId, chatId) {
        return (this._transport.request('get_chat_securejoin_qr_code_svg', [accountId, chatId]));
    }
    /**
     * Continue a Setup-Contact or Verified-Group-Invite protocol
     * started on another device with `get_chat_securejoin_qr_code_svg()`.
     * This function is typically called when `check_qr()` returns
     * type=AskVerifyContact or type=AskVerifyGroup.
     *
     * The function returns immediately and the handshake runs in background,
     * sending and receiving several messages.
     * During the handshake, info messages are added to the chat,
     * showing progress, success or errors.
     *
     * Subsequent calls of `secure_join()` will abort previous, unfinished handshakes.
     *
     * See https://countermitm.readthedocs.io/en/latest/new.html
     * for details about both protocols.
     *
     * **qr**: The text of the scanned QR code. Typically, the same string as given
     *     to `check_qr()`.
     *
     * **returns**: The chat ID of the joined chat, the UI may redirect to the this chat.
     *         A returned chat ID does not guarantee that the chat is protected or the belonging contact is verified.
     *
     */
    secureJoin(accountId, qr) {
        return (this._transport.request('secure_join', [accountId, qr]));
    }
    leaveGroup(accountId, chatId) {
        return (this._transport.request('leave_group', [accountId, chatId]));
    }
    /**
     * Remove a member from a group.
     *
     * If the group is already _promoted_ (any message was sent to the group),
     * all group members are informed by a special status message that is sent automatically by this function.
     *
     * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
     */
    removeContactFromChat(accountId, chatId, contactId) {
        return (this._transport.request('remove_contact_from_chat', [accountId, chatId, contactId]));
    }
    /**
     * Add a member to a group.
     *
     * If the group is already _promoted_ (any message was sent to the group),
     * all group members are informed by a special status message that is sent automatically by this function.
     *
     * If the group has group protection enabled, only verified contacts can be added to the group.
     *
     * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
     */
    addContactToChat(accountId, chatId, contactId) {
        return (this._transport.request('add_contact_to_chat', [accountId, chatId, contactId]));
    }
    /**
     * Get the contact IDs belonging to a chat.
     *
     * - for normal chats, the function always returns exactly one contact,
     *   DC_CONTACT_ID_SELF is returned only for SELF-chats.
     *
     * - for group chats all members are returned, DC_CONTACT_ID_SELF is returned
     *   explicitly as it may happen that oneself gets removed from a still existing
     *   group
     *
     * - for broadcasts, all recipients are returned, DC_CONTACT_ID_SELF is not included
     *
     * - for mailing lists, the behavior is not documented currently, we will decide on that later.
     *   for now, the UI should not show the list for mailing lists.
     *   (we do not know all members and there is not always a global mailing list address,
     *   so we could return only SELF or the known members; this is not decided yet)
     */
    getChatContacts(accountId, chatId) {
        return (this._transport.request('get_chat_contacts', [accountId, chatId]));
    }
    /**
     * Create a new group chat.
     *
     * After creation,
     * the group has one member with the ID DC_CONTACT_ID_SELF
     * and is in _unpromoted_ state.
     * This means, you can add or remove members, change the name,
     * the group image and so on without messages being sent to all group members.
     *
     * This changes as soon as the first message is sent to the group members
     * and the group becomes _promoted_.
     * After that, all changes are synced with all group members
     * by sending status message.
     *
     * To check, if a chat is still unpromoted, you can look at the `is_unpromoted` property of `BasicChat` or `FullChat`.
     * This may be useful if you want to show some help for just created groups.
     *
     * @param protect If set to 1 the function creates group with protection initially enabled.
     *     Only verified members are allowed in these groups
     *     and end-to-end-encryption is always enabled.
     */
    createGroupChat(accountId, name, protect) {
        return (this._transport.request('create_group_chat', [accountId, name, protect]));
    }
    /**
     * Create a new broadcast list.
     *
     * Broadcast lists are similar to groups on the sending device,
     * however, recipients get the messages in a read-only chat
     * and will see who the other members are.
     *
     * For historical reasons, this function does not take a name directly,
     * instead you have to set the name using dc_set_chat_name()
     * after creating the broadcast list.
     */
    createBroadcastList(accountId) {
        return (this._transport.request('create_broadcast_list', [accountId]));
    }
    /**
     * Set group name.
     *
     * If the group is already _promoted_ (any message was sent to the group),
     * all group members are informed by a special status message that is sent automatically by this function.
     *
     * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
     */
    setChatName(accountId, chatId, newName) {
        return (this._transport.request('set_chat_name', [accountId, chatId, newName]));
    }
    /**
     * Set group profile image.
     *
     * If the group is already _promoted_ (any message was sent to the group),
     * all group members are informed by a special status message that is sent automatically by this function.
     *
     * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
     *
     * To find out the profile image of a chat, use dc_chat_get_profile_image()
     *
     * @param image_path Full path of the image to use as the group image. The image will immediately be copied to the
     *     `blobdir`; the original image will not be needed anymore.
     *      If you pass null here, the group image is deleted (for promoted groups, all members are informed about
     *      this change anyway).
     */
    setChatProfileImage(accountId, chatId, imagePath) {
        return (this._transport.request('set_chat_profile_image', [accountId, chatId, imagePath]));
    }
    setChatVisibility(accountId, chatId, visibility) {
        return (this._transport.request('set_chat_visibility', [accountId, chatId, visibility]));
    }
    setChatEphemeralTimer(accountId, chatId, timer) {
        return (this._transport.request('set_chat_ephemeral_timer', [accountId, chatId, timer]));
    }
    getChatEphemeralTimer(accountId, chatId) {
        return (this._transport.request('get_chat_ephemeral_timer', [accountId, chatId]));
    }
    addDeviceMessage(accountId, label, text) {
        return (this._transport.request('add_device_message', [accountId, label, text]));
    }
    /**
     *  Mark all messages in a chat as _noticed_.
     *  _Noticed_ messages are no longer _fresh_ and do not count as being unseen
     *  but are still waiting for being marked as "seen" using markseen_msgs()
     *  (IMAP/MDNs is not done for noticed messages).
     *
     *  Calling this function usually results in the event #DC_EVENT_MSGS_NOTICED.
     *  See also markseen_msgs().
     */
    marknoticedChat(accountId, chatId) {
        return (this._transport.request('marknoticed_chat', [accountId, chatId]));
    }
    getFirstUnreadMessageOfChat(accountId, chatId) {
        return (this._transport.request('get_first_unread_message_of_chat', [accountId, chatId]));
    }
    /**
     * Set mute duration of a chat.
     *
     * The UI can then call is_chat_muted() when receiving a new message
     * to decide whether it should trigger an notification.
     *
     * Muted chats should not sound or vibrate
     * and should not show a visual notification in the system area.
     * Moreover, muted chats should be excluded from global badge counter
     * (get_fresh_msgs() skips muted chats therefore)
     * and the in-app, per-chat badge counter should use a less obtrusive color.
     *
     * Sends out #DC_EVENT_CHAT_MODIFIED.
     */
    setChatMuteDuration(accountId, chatId, duration) {
        return (this._transport.request('set_chat_mute_duration', [accountId, chatId, duration]));
    }
    /**
     * Check whether the chat is currently muted (can be changed by set_chat_mute_duration()).
     *
     * This is available as a standalone function outside of fullchat, because it might be only needed for notification
     */
    isChatMuted(accountId, chatId) {
        return (this._transport.request('is_chat_muted', [accountId, chatId]));
    }
    /**
     * Mark messages as presented to the user.
     * Typically, UIs call this function on scrolling through the message list,
     * when the messages are presented at least for a little moment.
     * The concrete action depends on the type of the chat and on the users settings
     * (dc_msgs_presented() may be a better name therefore, but well. :)
     *
     * - For normal chats, the IMAP state is updated, MDN is sent
     *   (if set_config()-options `mdns_enabled` is set)
     *   and the internal state is changed to @ref DC_STATE_IN_SEEN to reflect these actions.
     *
     * - For contact requests, no IMAP or MDNs is done
     *   and the internal state is not changed therefore.
     *   See also marknoticed_chat().
     *
     * Moreover, timer is started for incoming ephemeral messages.
     * This also happens for contact requests chats.
     *
     * This function updates `last_msg_id` configuration value
     * to the maximum of the current value and IDs passed to this function.
     * Bots which mark messages as seen can rely on this side effect
     * to avoid updating `last_msg_id` value manually.
     *
     * One #DC_EVENT_MSGS_NOTICED event is emitted per modified chat.
     */
    markseenMsgs(accountId, msgIds) {
        return (this._transport.request('markseen_msgs', [accountId, msgIds]));
    }
    getMessageIds(accountId, chatId, infoOnly, addDaymarker) {
        return (this._transport.request('get_message_ids', [accountId, chatId, infoOnly, addDaymarker]));
    }
    getMessageListItems(accountId, chatId, infoOnly, addDaymarker) {
        return (this._transport.request('get_message_list_items', [accountId, chatId, infoOnly, addDaymarker]));
    }
    getMessage(accountId, messageId) {
        return (this._transport.request('get_message', [accountId, messageId]));
    }
    getMessageHtml(accountId, messageId) {
        return (this._transport.request('get_message_html', [accountId, messageId]));
    }
    /**
     * get multiple messages in one call,
     * if loading one message fails the error is stored in the result object in it's place.
     *
     * this is the batch variant of [get_message]
     */
    getMessages(accountId, messageIds) {
        return (this._transport.request('get_messages', [accountId, messageIds]));
    }
    /**
     * Fetch info desktop needs for creating a notification for a message
     */
    getMessageNotificationInfo(accountId, messageId) {
        return (this._transport.request('get_message_notification_info', [accountId, messageId]));
    }
    /**
     * Delete messages. The messages are deleted on the current device and
     * on the IMAP server.
     */
    deleteMessages(accountId, messageIds) {
        return (this._transport.request('delete_messages', [accountId, messageIds]));
    }
    /**
     * Get an informational text for a single message. The text is multiline and may
     * contain e.g. the raw text of the message.
     *
     * The max. text returned is typically longer (about 100000 characters) than the
     * max. text returned by dc_msg_get_text() (about 30000 characters).
     */
    getMessageInfo(accountId, messageId) {
        return (this._transport.request('get_message_info', [accountId, messageId]));
    }
    /**
     * Returns additional information for single message.
     */
    getMessageInfoObject(accountId, messageId) {
        return (this._transport.request('get_message_info_object', [accountId, messageId]));
    }
    /**
     * Returns contacts that sent read receipts and the time of reading.
     */
    getMessageReadReceipts(accountId, messageId) {
        return (this._transport.request('get_message_read_receipts', [accountId, messageId]));
    }
    /**
     * Asks the core to start downloading a message fully.
     * This function is typically called when the user hits the "Download" button
     * that is shown by the UI in case `download_state` is `'Available'` or `'Failure'`
     *
     * On success, the @ref DC_MSG "view type of the message" may change
     * or the message may be replaced completely by one or more messages with other message IDs.
     * That may happen e.g. in cases where the message was encrypted
     * and the type could not be determined without fully downloading.
     * Downloaded content can be accessed as usual after download.
     *
     * To reflect these changes a @ref DC_EVENT_MSGS_CHANGED event will be emitted.
     */
    downloadFullMessage(accountId, messageId) {
        return (this._transport.request('download_full_message', [accountId, messageId]));
    }
    /**
     * Search messages containing the given query string.
     * Searching can be done globally (chat_id=None) or in a specified chat only (chat_id set).
     *
     * Global search results are typically displayed using dc_msg_get_summary(), chat
     * search results may just highlight the corresponding messages and present a
     * prev/next button.
     *
     * For the global search, the result is limited to 1000 messages,
     * this allows an incremental search done fast.
     * So, when getting exactly 1000 messages, the result actually may be truncated;
     * the UIs may display sth. like "1000+ messages found" in this case.
     * The chat search (if chat_id is set) is not limited.
     */
    searchMessages(accountId, query, chatId) {
        return (this._transport.request('search_messages', [accountId, query, chatId]));
    }
    messageIdsToSearchResults(accountId, messageIds) {
        return (this._transport.request('message_ids_to_search_results', [accountId, messageIds]));
    }
    /**
     * Get a single contact options by ID.
     */
    getContact(accountId, contactId) {
        return (this._transport.request('get_contact', [accountId, contactId]));
    }
    /**
     * Add a single contact as a result of an explicit user action.
     *
     * Returns contact id of the created or existing contact
     */
    createContact(accountId, email, name) {
        return (this._transport.request('create_contact', [accountId, email, name]));
    }
    /**
     * Returns contact id of the created or existing DM chat with that contact
     */
    createChatByContactId(accountId, contactId) {
        return (this._transport.request('create_chat_by_contact_id', [accountId, contactId]));
    }
    blockContact(accountId, contactId) {
        return (this._transport.request('block_contact', [accountId, contactId]));
    }
    unblockContact(accountId, contactId) {
        return (this._transport.request('unblock_contact', [accountId, contactId]));
    }
    getBlockedContacts(accountId) {
        return (this._transport.request('get_blocked_contacts', [accountId]));
    }
    getContactIds(accountId, listFlags, query) {
        return (this._transport.request('get_contact_ids', [accountId, listFlags, query]));
    }
    /**
     * Get a list of contacts.
     * (formerly called getContacts2 in desktop)
     */
    getContacts(accountId, listFlags, query) {
        return (this._transport.request('get_contacts', [accountId, listFlags, query]));
    }
    getContactsByIds(accountId, ids) {
        return (this._transport.request('get_contacts_by_ids', [accountId, ids]));
    }
    deleteContact(accountId, contactId) {
        return (this._transport.request('delete_contact', [accountId, contactId]));
    }
    changeContactName(accountId, contactId, name) {
        return (this._transport.request('change_contact_name', [accountId, contactId, name]));
    }
    /**
     * Get encryption info for a contact.
     * Get a multi-line encryption info, containing your fingerprint and the
     * fingerprint of the contact, used e.g. to compare the fingerprints for a simple out-of-band verification.
     */
    getContactEncryptionInfo(accountId, contactId) {
        return (this._transport.request('get_contact_encryption_info', [accountId, contactId]));
    }
    /**
     * Check if an e-mail address belongs to a known and unblocked contact.
     * To get a list of all known and unblocked contacts, use contacts_get_contacts().
     *
     * To validate an e-mail address independently of the contact database
     * use check_email_validity().
     */
    lookupContactIdByAddr(accountId, addr) {
        return (this._transport.request('lookup_contact_id_by_addr', [accountId, addr]));
    }
    /**
     * Returns the [`ChatId`] for the 1:1 chat with `contact_id` if it exists.
     *
     * If it does not exist, `None` is returned.
     */
    getChatIdByContactId(accountId, contactId) {
        return (this._transport.request('get_chat_id_by_contact_id', [accountId, contactId]));
    }
    /**
     * Returns all message IDs of the given types in a chat.
     * Typically used to show a gallery.
     *
     * The list is already sorted and starts with the oldest message.
     * Clients should not try to re-sort the list as this would be an expensive action
     * and would result in inconsistencies between clients.
     *
     * Setting `chat_id` to `None` (`null` in typescript) means get messages with media
     * from any chat of the currently used account.
     */
    getChatMedia(accountId, chatId, messageType, orMessageType2, orMessageType3) {
        return (this._transport.request('get_chat_media', [accountId, chatId, messageType, orMessageType2, orMessageType3]));
    }
    /**
     * Search next/previous message based on a given message and a list of types.
     * Typically used to implement the "next" and "previous" buttons
     * in a gallery or in a media player.
     *
     * one combined call for getting chat::get_next_media for both directions
     * the manual chat::get_next_media in only one direction is not exposed by the jsonrpc yet
     *
     * Deprecated 2023-10-03, use `get_chat_media` method
     * and navigate the returned array instead.
     */
    getNeighboringChatMedia(accountId, msgId, messageType, orMessageType2, orMessageType3) {
        return (this._transport.request('get_neighboring_chat_media', [accountId, msgId, messageType, orMessageType2, orMessageType3]));
    }
    exportBackup(accountId, destination, passphrase) {
        return (this._transport.request('export_backup', [accountId, destination, passphrase]));
    }
    importBackup(accountId, path, passphrase) {
        return (this._transport.request('import_backup', [accountId, path, passphrase]));
    }
    /**
     * Offers a backup for remote devices to retrieve.
     *
     * Can be cancelled by stopping the ongoing process.  Success or failure can be tracked
     * via the `ImexProgress` event which should either reach `1000` for success or `0` for
     * failure.
     *
     * This **stops IO** while it is running.
     *
     * Returns once a remote device has retrieved the backup, or is cancelled.
     */
    provideBackup(accountId) {
        return (this._transport.request('provide_backup', [accountId]));
    }
    /**
     * Returns the text of the QR code for the running [`CommandApi::provide_backup`].
     *
     * This QR code text can be used in [`CommandApi::get_backup`] on a second device to
     * retrieve the backup and setup this second device.
     *
     * This call will fail if there is currently no concurrent call to
     * [`CommandApi::provide_backup`].  This call may block if the QR code is not yet
     * ready.
     */
    getBackupQr(accountId) {
        return (this._transport.request('get_backup_qr', [accountId]));
    }
    /**
     * Returns the rendered QR code for the running [`CommandApi::provide_backup`].
     *
     * This QR code can be used in [`CommandApi::get_backup`] on a second device to
     * retrieve the backup and setup this second device.
     *
     * This call will fail if there is currently no concurrent call to
     * [`CommandApi::provide_backup`].  This call may block if the QR code is not yet
     * ready.
     *
     * Returns the QR code rendered as an SVG image.
     */
    getBackupQrSvg(accountId) {
        return (this._transport.request('get_backup_qr_svg', [accountId]));
    }
    /**
     * Gets a backup from a remote provider.
     *
     * This retrieves the backup from a remote device over the network and imports it into
     * the current device.
     *
     * Can be cancelled by stopping the ongoing process.
     */
    getBackup(accountId, qrText) {
        return (this._transport.request('get_backup', [accountId, qrText]));
    }
    /**
     * Indicate that the network likely has come back.
     * or just that the network conditions might have changed
     */
    maybeNetwork() {
        return (this._transport.request('maybe_network', []));
    }
    /**
     * Get the current connectivity, i.e. whether the device is connected to the IMAP server.
     * One of:
     * - DC_CONNECTIVITY_NOT_CONNECTED (1000-1999): Show e.g. the string "Not connected" or a red dot
     * - DC_CONNECTIVITY_CONNECTING (2000-2999): Show e.g. the string "Connecting…" or a yellow dot
     * - DC_CONNECTIVITY_WORKING (3000-3999): Show e.g. the string "Getting new messages" or a spinning wheel
     * - DC_CONNECTIVITY_CONNECTED (>=4000): Show e.g. the string "Connected" or a green dot
     *
     * We don't use exact values but ranges here so that we can split up
     * states into multiple states in the future.
     *
     * Meant as a rough overview that can be shown
     * e.g. in the title of the main screen.
     *
     * If the connectivity changes, a #DC_EVENT_CONNECTIVITY_CHANGED will be emitted.
     */
    getConnectivity(accountId) {
        return (this._transport.request('get_connectivity', [accountId]));
    }
    /**
     * Get an overview of the current connectivity, and possibly more statistics.
     * Meant to give the user more insight about the current status than
     * the basic connectivity info returned by get_connectivity(); show this
     * e.g., if the user taps on said basic connectivity info.
     *
     * If this page changes, a #DC_EVENT_CONNECTIVITY_CHANGED will be emitted.
     *
     * This comes as an HTML from the core so that we can easily improve it
     * and the improvement instantly reaches all UIs.
     */
    getConnectivityHtml(accountId) {
        return (this._transport.request('get_connectivity_html', [accountId]));
    }
    getLocations(accountId, chatId, contactId, timestampBegin, timestampEnd) {
        return (this._transport.request('get_locations', [accountId, chatId, contactId, timestampBegin, timestampEnd]));
    }
    sendWebxdcStatusUpdate(accountId, instanceMsgId, updateStr, description) {
        return (this._transport.request('send_webxdc_status_update', [accountId, instanceMsgId, updateStr, description]));
    }
    getWebxdcStatusUpdates(accountId, instanceMsgId, lastKnownSerial) {
        return (this._transport.request('get_webxdc_status_updates', [accountId, instanceMsgId, lastKnownSerial]));
    }
    /**
     * Get info from a webxdc message
     */
    getWebxdcInfo(accountId, instanceMsgId) {
        return (this._transport.request('get_webxdc_info', [accountId, instanceMsgId]));
    }
    /**
     * Get blob encoded as base64 from a webxdc message
     *
     * path is the path of the file within webxdc archive
     */
    getWebxdcBlob(accountId, instanceMsgId, path) {
        return (this._transport.request('get_webxdc_blob', [accountId, instanceMsgId, path]));
    }
    /**
     * Makes an HTTP GET request and returns a response.
     *
     * `url` is the HTTP or HTTPS URL.
     */
    getHttpResponse(accountId, url) {
        return (this._transport.request('get_http_response', [accountId, url]));
    }
    /**
     * Forward messages to another chat.
     *
     * All types of messages can be forwarded,
     * however, they will be flagged as such (dc_msg_is_forwarded() is set).
     *
     * Original sender, info-state and webxdc updates are not forwarded on purpose.
     */
    forwardMessages(accountId, messageIds, chatId) {
        return (this._transport.request('forward_messages', [accountId, messageIds, chatId]));
    }
    /**
     * Resend messages and make information available for newly added chat members.
     * Resending sends out the original message, however, recipients and webxdc-status may differ.
     * Clients that already have the original message can still ignore the resent message as
     * they have tracked the state by dedicated updates.
     *
     * Some messages cannot be resent, eg. info-messages, drafts, already pending messages or messages that are not sent by SELF.
     *
     * message_ids all message IDs that should be resend. All messages must belong to the same chat.
     */
    resendMessages(accountId, messageIds) {
        return (this._transport.request('resend_messages', [accountId, messageIds]));
    }
    sendSticker(accountId, chatId, stickerPath) {
        return (this._transport.request('send_sticker', [accountId, chatId, stickerPath]));
    }
    /**
     * Send a reaction to message.
     *
     * Reaction is a string of emojis separated by spaces. Reaction to a
     * single message can be sent multiple times. The last reaction
     * received overrides all previously received reactions. It is
     * possible to remove all reactions by sending an empty string.
     */
    sendReaction(accountId, messageId, reaction) {
        return (this._transport.request('send_reaction', [accountId, messageId, reaction]));
    }
    /**
     * Returns reactions to the message.
     */
    getMessageReactions(accountId, messageId) {
        return (this._transport.request('get_message_reactions', [accountId, messageId]));
    }
    sendMsg(accountId, chatId, data) {
        return (this._transport.request('send_msg', [accountId, chatId, data]));
    }
    /**
     * Checks if messages can be sent to a given chat.
     */
    canSend(accountId, chatId) {
        return (this._transport.request('can_send', [accountId, chatId]));
    }
    removeDraft(accountId, chatId) {
        return (this._transport.request('remove_draft', [accountId, chatId]));
    }
    /**
     *  Get draft for a chat, if any.
     */
    getDraft(accountId, chatId) {
        return (this._transport.request('get_draft', [accountId, chatId]));
    }
    sendVideochatInvitation(accountId, chatId) {
        return (this._transport.request('send_videochat_invitation', [accountId, chatId]));
    }
    miscGetStickerFolder(accountId) {
        return (this._transport.request('misc_get_sticker_folder', [accountId]));
    }
    /**
     * Saves a sticker to a collection/folder in the account's sticker folder.
     */
    miscSaveSticker(accountId, msgId, collection) {
        return (this._transport.request('misc_save_sticker', [accountId, msgId, collection]));
    }
    /**
     * for desktop, get stickers from stickers folder,
     * grouped by the collection/folder they are in.
     */
    miscGetStickers(accountId) {
        return (this._transport.request('misc_get_stickers', [accountId]));
    }
    /**
     * Returns the messageid of the sent message
     */
    miscSendTextMessage(accountId, chatId, text) {
        return (this._transport.request('misc_send_text_message', [accountId, chatId, text]));
    }
    miscSendMsg(accountId, chatId, text, file, location, quotedMessageId) {
        return (this._transport.request('misc_send_msg', [accountId, chatId, text, file, location, quotedMessageId]));
    }
    miscSetDraft(accountId, chatId, text, file, quotedMessageId, viewType) {
        return (this._transport.request('misc_set_draft', [accountId, chatId, text, file, quotedMessageId, viewType]));
    }
    miscSendDraft(accountId, chatId) {
        return (this._transport.request('misc_send_draft', [accountId, chatId]));
    }
}
//# sourceMappingURL=client.js.map